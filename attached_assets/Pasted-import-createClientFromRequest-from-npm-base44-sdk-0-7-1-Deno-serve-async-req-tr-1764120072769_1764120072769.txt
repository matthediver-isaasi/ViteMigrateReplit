import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const { accessToken } = await req.json();
        
        if (!accessToken) {
            return Response.json({ 
                error: 'Missing access token' 
            }, { status: 400 });
        }

        const portalId = "20108049755";
        const baseUrl = "https://www.zohoapis.eu/backstage/v3";
        const url = `${baseUrl}/portals/${portalId}/events?status=live`;

        console.log('Fetching events from:', url);

        const eventsResponse = await fetch(url, {
            method: 'GET',
            headers: {
                'Authorization': `Zoho-oauthtoken ${accessToken}`
            }
        });

        if (!eventsResponse.ok) {
            const errorText = await eventsResponse.text();
            console.error('API error:', errorText);
            return Response.json({ 
                error: 'Failed to fetch events from Backstage',
                details: errorText,
                url: url,
                status: eventsResponse.status
            }, { status: eventsResponse.status });
        }

        const eventsData = await eventsResponse.json();
        const events = eventsData.events || [];
        console.log('Found events:', events.length);

        if (events.length === 0) {
            return Response.json({
                success: true,
                synced: 0,
                errors: 0,
                total: 0,
                message: 'No events found in response'
            });
        }

        let syncedCount = 0;
        let errorCount = 0;
        const errors = [];

        const allExistingEvents = await base44.asServiceRole.entities.Event.list();
        console.log('Existing events in DB:', allExistingEvents.length);

        for (const event of events) {
            try {
                console.log('Processing event:', event.name, 'ID:', event.id);
                
                const programTag = event.tags && event.tags.length > 0 ? event.tags[0] : null;

                // Fetch ticket classes for this event
                const ticketClassesUrl = `${baseUrl}/portals/${portalId}/events/${event.id}/ticket_classes`;
                console.log('Fetching ticket classes from:', ticketClassesUrl);
                
                const ticketClassesResponse = await fetch(ticketClassesUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Zoho-oauthtoken ${accessToken}`
                    }
                });

                let ticketTypeId = null;
                let ticketPrice = 0;
                let availableSeats = 0;

                if (ticketClassesResponse.ok) {
                    const ticketClassesData = await ticketClassesResponse.json();
                    const ticketClasses = ticketClassesData.ticket_classes || [];
                    
                    console.log(`Found ${ticketClasses.length} ticket classes for event ${event.name}`);
                    
                    // Find the "Member" ticket class (free, might be hidden)
                    let memberTicket = ticketClasses.find(tc => 
                        tc.translation?.name?.toLowerCase() === 'member' || 
                        tc.ticket_class_type_string === 'free'
                    );
                    
                    // If no member ticket found, use the first ticket class
                    if (!memberTicket && ticketClasses.length > 0) {
                        memberTicket = ticketClasses[0];
                        console.log('No "Member" ticket found, using first ticket class');
                    }
                    
                    if (memberTicket) {
                        ticketTypeId = memberTicket.id.toString();
                        ticketPrice = parseFloat(memberTicket.amount || 0);
                        availableSeats = parseInt((memberTicket.quantity || 0) - (memberTicket.sold || 0));
                        
                        console.log('Selected ticket class:', {
                            id: ticketTypeId,
                            name: memberTicket.translation?.name,
                            price: ticketPrice,
                            available: availableSeats,
                            type: memberTicket.ticket_class_type_string
                        });
                    }
                } else {
                    const error = await ticketClassesResponse.text();
                    console.error('Failed to fetch ticket classes:', error);
                }

                const eventData = {
                    title: event.name,
                    description: event.description || '',
                    program_tag: programTag,
                    start_date: event.start_time,
                    end_date: event.end_time,
                    location: event.venue?.name || 'Online',
                    ticket_price: ticketPrice,
                    available_seats: availableSeats,
                    backstage_event_id: event.id.toString(),
                    backstage_ticket_type_id: ticketTypeId,
                    image_url: event.banner_url || event.thumbnail_url || null,
                    last_synced: new Date().toISOString()
                };

                console.log('Event data to save:', JSON.stringify(eventData, null, 2));

                const existingEvent = allExistingEvents.find(e => e.backstage_event_id === eventData.backstage_event_id);

                if (existingEvent) {
                    await base44.asServiceRole.entities.Event.update(existingEvent.id, eventData);
                    console.log('✓ Updated event:', eventData.title);
                } else {
                    await base44.asServiceRole.entities.Event.create(eventData);
                    console.log('✓ Created event:', eventData.title);
                }

                syncedCount++;
            } catch (error) {
                console.error(`✗ Error syncing event ${event.id}:`, error);
                errors.push({ eventId: event.id, error: error.message });
                errorCount++;
            }
        }

        return Response.json({
            success: true,
            synced: syncedCount,
            errors: errorCount,
            total: events.length,
            errorDetails: errors.length > 0 ? errors : undefined
        });

    } catch (error) {
        console.error('Fatal sync error:', error);
        return Response.json({ 
            error: 'Failed to sync events',
            message: error.message,
            stack: error.stack
        }, { status: 500 });
    }
});