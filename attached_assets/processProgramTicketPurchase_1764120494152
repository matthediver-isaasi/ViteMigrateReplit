
import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';
import Stripe from 'npm:stripe@14.10.0';

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY'));

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);

        const { 
            memberEmail, 
            programName, 
            quantity, 
            purchaseOrderNumber,
            selectedVoucherIds = [],
            trainingFundAmount = 0,
            accountAmount = 0,
            paymentMethod = 'account',
            stripePaymentIntentId = null,
            appliedDiscountId = null
        } = await req.json();
        
        if (!memberEmail || !programName || !quantity) {
            return Response.json({ 
                error: 'Missing required parameters',
                required: ['memberEmail', 'programName', 'quantity']
            }, { status: 400 });
        }

        if (quantity < 1 || quantity > 1000) {
            return Response.json({ 
                error: 'Quantity must be between 1 and 1000'
            }, { status: 400 });
        }

        // Verify Stripe payment if card payment method
        if (paymentMethod === 'card' && stripePaymentIntentId) {
            try {
                const paymentIntent = await stripe.paymentIntents.retrieve(stripePaymentIntentId);
                
                if (paymentIntent.status !== 'succeeded') {
                    return Response.json({
                        error: 'Payment not completed',
                        details: `Payment status: ${paymentIntent.status}`
                    }, { status: 400 });
                }
                
                console.log('[processProgramTicketPurchase] Stripe payment verified:', paymentIntent.id);
            } catch (stripeError) {
                console.error('[processProgramTicketPurchase] Stripe verification failed:', stripeError);
                return Response.json({
                    error: 'Failed to verify payment',
                    details: stripeError.message
                }, { status: 400 });
            }
        }

        // Verify that the program exists and is active
        const allPrograms = await base44.asServiceRole.entities.Program.list();
        const program = allPrograms.find(p => p.program_tag === programName && p.is_active);
        
        if (!program) {
            return Response.json({ 
                error: 'Program not found or not active',
                programName: programName
            }, { status: 404 });
        }

        // Get member's organization
        const allMembers = await base44.asServiceRole.entities.Member.list();
        const member = allMembers.find(m => m.email === memberEmail);

        if (!member || !member.organization_id) {
            return Response.json({ 
                error: 'Member or organization not found'
            }, { status: 404 });
        }

        // Get organization
        const allOrgs = await base44.asServiceRole.entities.Organization.list();
        let org = allOrgs.find(o => o.id === member.organization_id);
        
        if (!org) {
            org = allOrgs.find(o => o.zoho_account_id === member.organization_id);
        }

        if (!org) {
            return Response.json({ 
                error: 'Organization not found'
            }, { status: 404 });
        }

        // DECLARE ALL VARIABLES AT THE TOP - BEFORE ANY COST CALCULATIONS
        let totalCost; 
        let totalTicketsReceived;
        let discountApplied = false;
        let discountDetails = '';
        let costBeforeDiscountCodeApplication; // Store the cost after BOGO/bulk but before any potential discount code application
        let discountAmount = 0; // Amount from discount code application
        let discountCode = null; // Object for the discount code
        
        // Determine effective offer type (for backward compatibility)
        const offerType = program.offer_type || "none";
        let effectiveOfferType = offerType;
        if (offerType === "none") {
          if (program.bogo_buy_quantity && program.bogo_get_free_quantity) {
            effectiveOfferType = "bogo";
          } else if (program.bulk_discount_threshold && program.bulk_discount_percentage) {
            effectiveOfferType = "bulk_discount";
          }
        }
        
        // Calculate cost and total tickets based on offer type
        // totalCost will initially hold the cost *after* BOGO/bulk, and then *after* discount code.
        
        if (effectiveOfferType === "bogo") {
            const bogoLogicType = program.bogo_logic_type || 'buy_x_get_y_free';
            
            if (bogoLogicType === 'buy_x_get_y_free') {
                // LEGACY LOGIC: User enters qty to purchase, receives qty + free, pays for qty
                
                if (program.bogo_buy_quantity && program.bogo_get_free_quantity && 
                    quantity >= program.bogo_buy_quantity) {
                    const bogoBlocks = Math.floor(quantity / program.bogo_buy_quantity);
                    const freeTickets = bogoBlocks * program.bogo_get_free_quantity;
                    
                    totalTicketsReceived = quantity + freeTickets;
                    totalCost = program.program_ticket_price * quantity; // Cost for original quantity
                    
                    discountApplied = true;
                    discountDetails = `Buy ${program.bogo_buy_quantity}, Get ${program.bogo_get_free_quantity} Free - ${freeTickets} free ticket${freeTickets > 1 ? 's' : ''} received`;
                } else {
                    totalTicketsReceived = quantity; // Quantity purchased
                    totalCost = program.program_ticket_price * quantity; // Base cost
                }
            } else { // 'enter_total_pay_less'
                // NEW LOGIC: User enters total qty wanted, pays for fewer
                totalTicketsReceived = quantity; // quantity is the total they want to receive
                
                if (program.bogo_buy_quantity && program.bogo_get_free_quantity && 
                    quantity >= (program.bogo_buy_quantity + program.bogo_get_free_quantity)) {
                    const bogoSetSize = program.bogo_buy_quantity + program.bogo_get_free_quantity;
                    const completeBlocks = Math.floor(quantity / bogoSetSize);
                    const remainingTickets = quantity % bogoSetSize;
                    const freeTickets = completeBlocks * program.bogo_get_free_quantity;
                    
                    // Pay for 'buy' tickets in each complete block, plus remaining tickets
                    const ticketsToPay = (completeBlocks * program.bogo_buy_quantity) + remainingTickets;
                    totalCost = program.program_ticket_price * ticketsToPay;
                    
                    discountApplied = true;
                    discountDetails = `BOGO offer applied - ${freeTickets} free ticket${freeTickets > 1 ? 's' : ''} included in your ${quantity} ticket${quantity > 1 ? 's' : ''}`;
                } else {
                    totalCost = program.program_ticket_price * quantity;
                }
            }
        } else if (effectiveOfferType === "bulk_discount") {
            // Percentage bulk discount
            totalTicketsReceived = quantity; // Quantity purchased
            totalCost = program.program_ticket_price * quantity;
            
            if (program.bulk_discount_threshold && program.bulk_discount_percentage && 
                quantity >= program.bulk_discount_threshold) {
                const bulkDiscountValue = totalCost * (program.bulk_discount_percentage / 100);
                totalCost = totalCost - bulkDiscountValue; // Cost after bulk discount
                discountApplied = true;
                discountDetails = `${program.bulk_discount_percentage}% bulk discount`;
            }
        } else {
            // No offer
            totalTicketsReceived = quantity;
            totalCost = program.program_ticket_price * quantity;
        }

        // Store the current totalCost (after BOGO/bulk, before discount code)
        costBeforeDiscountCodeApplication = totalCost;

        // Apply discount code if provided
        if (appliedDiscountId) {
            const allDiscountCodes = await base44.asServiceRole.entities.DiscountCode.list();
            discountCode = allDiscountCodes.find(dc => dc.id === appliedDiscountId);

            if (discountCode && discountCode.is_active) {
                // Validate discount code again server-side
                if (discountCode.expires_at && new Date(discountCode.expires_at) < new Date()) {
                    return Response.json({
                        error: 'Discount code has expired'
                    }, { status: 400 });
                }

                if (discountCode.program_tag && discountCode.program_tag !== programName) {
                    return Response.json({
                        error: 'Discount code is not valid for this program'
                    }, { status: 400 });
                }

                // Validate usage count based on whether code is organization-specific
                if (discountCode.max_usage_count) {
                    let currentUsage = 0;

                    if (discountCode.organization_id) {
                        // Organization-specific code: check DiscountCodeUsage
                        const usageRecords = await base44.asServiceRole.entities.DiscountCodeUsage.filter({
                            discount_code_id: discountCode.id,
                            organization_id: org.id
                        });
                        
                        if (usageRecords.length > 0) {
                            currentUsage = usageRecords[0].usage_count || 0;
                        }
                    } else {
                        // Global code: check current_usage_count
                        currentUsage = discountCode.current_usage_count || 0;
                    }

                    if (currentUsage >= discountCode.max_usage_count) {
                        return Response.json({
                            error: 'Discount code has reached its maximum usage'
                        }, { status: 400 });
                    }
                }

                // Calculate discount
                if (discountCode.type === 'percentage') {
                    discountAmount = totalCost * (discountCode.value / 100);
                } else if (discountCode.type === 'fixed') {
                    discountAmount = discountCode.value;
                }

                // Ensure discount doesn't make totalCost negative
                discountAmount = Math.min(discountAmount, totalCost); 
                totalCost = totalCost - discountAmount; // totalCost now reflects both BOGO/bulk and discount code

                // Increment usage count based on code type
                if (discountCode.organization_id) {
                    // Organization-specific code: update or create DiscountCodeUsage
                    const usageRecords = await base44.asServiceRole.entities.DiscountCodeUsage.filter({
                        discount_code_id: discountCode.id,
                        organization_id: org.id
                    });

                    if (usageRecords.length > 0) {
                        // Update existing usage record
                        await base44.asServiceRole.entities.DiscountCodeUsage.update(usageRecords[0].id, {
                            usage_count: (usageRecords[0].usage_count || 0) + 1
                        });
                    } else {
                        // Create new usage record
                        await base44.asServiceRole.entities.DiscountCodeUsage.create({
                            discount_code_id: discountCode.id,
                            organization_id: org.id,
                            usage_count: 1
                        });
                    }
                    console.log(`[processProgramTicketPurchase] Updated organization-specific discount usage for org ${org.id}`);
                } else {
                    // Global code: increment current_usage_count on DiscountCode
                    await base44.asServiceRole.entities.DiscountCode.update(discountCode.id, {
                        current_usage_count: (discountCode.current_usage_count || 0) + 1
                    });
                    console.log(`[processProgramTicketPurchase] Updated global discount usage count`);
                }

                console.log(`[processProgramTicketPurchase] Applied discount code ${discountCode.code}: £${discountAmount.toFixed(2)} off`);
            } else {
                 return Response.json({
                    error: 'Invalid or inactive discount code provided.'
                 }, { status: 400 });
            }
        }

        // Fetch all vouchers once for validation and updates
        const allVouchers = await base44.asServiceRole.entities.Voucher.list();
        
        // Fetch and process selected vouchers with intelligent allocation
        let voucherAmountUsed = 0;
        const voucherUsageDetails = [];
        let remainingCost = totalCost; // Use the totalCost after all discounts
        
        if (selectedVoucherIds.length > 0) {
            const selectedVouchersData = selectedVoucherIds
                .map(voucherId => allVouchers.find(v => v.id === voucherId))
                .filter(v => v !== undefined)
                .sort((a, b) => {
                    const expiryA = new Date(a.expires_at).getTime();
                    const expiryB = new Date(b.expires_at).getTime();
                    
                    if (expiryA !== expiryB) {
                        return expiryA - expiryB;
                    }
                    
                    return a.value - b.value;
                });
            
            console.log('[processProgramTicketPurchase] Sorted vouchers for application:', selectedVouchersData.map(v => ({
                code: v.code,
                value: v.value,
                expires_at: v.expires_at
            })));
            
            for (const voucher of selectedVouchersData) {
                // Validate voucher
                if (voucher.organization_id !== org.id) {
                    return Response.json({
                        error: `Voucher ${voucher.code} does not belong to your organization`
                    }, { status: 403 });
                }
                
                if (voucher.status !== 'active') {
                    return Response.json({
                        error: `Voucher ${voucher.code} is not active`
                    }, { status: 400 });
                }
                
                const expiryDate = new Date(voucher.expires_at);
                if (expiryDate < new Date()) {
                    return Response.json({
                        error: `Voucher ${voucher.code} has expired`
                    }, { status: 400 });
                }
                
                if (remainingCost <= 0) {
                    break;
                }
                
                const amountToUse = Math.min(voucher.value, remainingCost);
                voucherAmountUsed += amountToUse;
                remainingCost -= amountToUse;
                
                console.log(`[processProgramTicketPurchase] Using £${amountToUse} from voucher ${voucher.code} (£${voucher.value}). Remaining cost: £${remainingCost}`);
                
                if (amountToUse >= voucher.value) {
                    await base44.asServiceRole.entities.Voucher.update(voucher.id, {
                        status: 'used',
                        used_at: new Date().toISOString()
                    });
                    voucherUsageDetails.push({
                        code: voucher.code,
                        voucherId: voucher.id,
                        amountUsed: amountToUse,
                        fullyUsed: true
                    });
                    console.log(`[processProgramTicketPurchase] Voucher ${voucher.code} fully used and marked as 'used'`);
                } else {
                    const newValue = voucher.value - amountToUse;
                    await base44.asServiceRole.entities.Voucher.update(voucher.id, {
                        value: newValue
                    });
                    voucherUsageDetails.push({
                        code: voucher.code,
                        voucherId: voucher.id,
                        amountUsed: amountToUse,
                        fullyUsed: false,
                        remainingValue: newValue
                    });
                    console.log(`[processProgramTicketPurchase] Voucher ${voucher.code} partially used. Remaining value: £${newValue}`);
                }
            }
        }

        // Verify payment allocation matches total cost
        const remainingAfterInternalFunds = totalCost - voucherAmountUsed - trainingFundAmount;
        const cardAmount = paymentMethod === 'card' ? remainingAfterInternalFunds : 0;
        const totalAllocated = voucherAmountUsed + trainingFundAmount + accountAmount + cardAmount;
        
        if (Math.abs(totalAllocated - totalCost) > 0.01) {
            return Response.json({
                error: 'Payment allocation does not match total cost',
                totalCost: parseFloat(totalCost.toFixed(2)),
                totalAllocated: parseFloat(totalAllocated.toFixed(2)),
                breakdown: {
                    vouchers: parseFloat(voucherAmountUsed.toFixed(2)),
                    trainingFund: parseFloat(trainingFundAmount.toFixed(2)),
                    account: parseFloat(accountAmount.toFixed(2)),
                    card: parseFloat(cardAmount.toFixed(2))
                }
            }, { status: 400 });
        }

        // Verify sufficient balances
        if (trainingFundAmount > (org.training_fund_balance || 0)) {
            return Response.json({
                error: 'Insufficient training fund balance',
                available: org.training_fund_balance || 0,
                requested: trainingFundAmount
            }, { status: 400 });
        }

        // Validate payment method specific requirements
        if (accountAmount > 0 && paymentMethod === 'account' && !purchaseOrderNumber) {
            return Response.json({
                error: 'Purchase order number required for account charges'
            }, { status: 400 });
        }

        // Update organization balances with TOTAL tickets received
        const currentProgramBalances = org.program_ticket_balances || {};
        const currentProgramBalance = currentProgramBalances[programName] || 0;
        const newProgramBalance = currentProgramBalance + totalTicketsReceived;
        
        const updatedProgramBalances = {
            ...currentProgramBalances,
            [programName]: newProgramBalance
        };

        const updateData = {
            program_ticket_balances: updatedProgramBalances,
            last_synced: new Date().toISOString()
        };

        // Deduct from training fund if used
        if (trainingFundAmount > 0) {
            updateData.training_fund_balance = (org.training_fund_balance || 0) - trainingFundAmount;
        }

        await base44.asServiceRole.entities.Organization.update(org.id, updateData);

        // Create transaction record with detailed payment breakdown
        const paymentMethods = [];
        if (voucherAmountUsed > 0) {
            const voucherSummary = voucherUsageDetails.map(v => 
                `${v.code} (£${v.amountUsed.toFixed(2)}${v.fullyUsed ? ' - fully used' : ` - £${v.remainingValue.toFixed(2)} remaining`})`
            ).join(', ');
            paymentMethods.push(`Vouchers: ${voucherSummary}`);
        }
        if (trainingFundAmount > 0) paymentMethods.push(`Training Fund: £${trainingFundAmount.toFixed(2)}`);
        if (accountAmount > 0) {
            paymentMethods.push(`Account: £${accountAmount.toFixed(2)}`);
        }
        if (cardAmount > 0) {
            paymentMethods.push(`Card: £${cardAmount.toFixed(2)}${stripePaymentIntentId ? ` (Stripe: ${stripePaymentIntentId})` : ''}`);
        }

        let transactionNotes = `Purchased ${quantity} ticket${quantity > 1 ? 's' : ''} for ${program.name}`;
        if (discountApplied) { // Refers to BOGO/bulk discount
            transactionNotes += ` (${discountDetails})`;
        }
        transactionNotes += `. Total tickets received: ${totalTicketsReceived}.`;
        
        if (discountCode) { // Refers to discount code application
            transactionNotes += ` Discount code ${discountCode.code} applied: £${discountAmount.toFixed(2)} off.`;
        }
        
        transactionNotes += ` Payment: ${paymentMethods.join(', ')}`;

        const transactionData = {
            organization_id: org.id,
            program_name: programName,
            transaction_type: 'purchase',
            quantity: totalTicketsReceived,
            original_quantity: totalTicketsReceived, // Added
            cancelled_quantity: 0, // Added
            status: 'active', // Added
            purchase_order_number: purchaseOrderNumber || null,
            member_email: memberEmail,
            notes: transactionNotes,
            discount_code_id: discountCode?.id || null,
            discount_amount_applied: discountAmount > 0 ? discountAmount : null,
            total_cost_before_discount: costBeforeDiscountCodeApplication
        };

        // If account charge or card payment, create Xero invoice
        if (accountAmount > 0 || cardAmount > 0) {
            try {
                console.log('[processProgramTicketPurchase] Creating Xero invoice with discount:', {
                    code: discountCode?.code,
                    type: discountCode?.type,
                    value: discountCode?.value,
                    paymentMethod: paymentMethod,
                    stripePaymentIntentId: stripePaymentIntentId
                });

                // Determine invoice amount (account charge or card payment)
                const invoiceAmount = paymentMethod === 'card' ? cardAmount : accountAmount;
                
                // Use Stripe Payment Intent ID as reference for card payments, or PO number for account
                const invoiceReference = paymentMethod === 'card' 
                    ? `Stripe Card Payment${stripePaymentIntentId ? ` - ${stripePaymentIntentId}` : ''}` 
                    : purchaseOrderNumber;

                const xeroResponse = await base44.asServiceRole.functions.invoke('createXeroInvoice', {
                    organizationName: org.name,
                    purchaseOrderNumber: invoiceReference,
                    programName: program.name,
                    baseTicketPrice: program.program_ticket_price,
                    totalCost: invoiceAmount,
                    totalTickets: totalTicketsReceived,
                    offerDetails: (discountApplied && discountDetails) ? discountDetails : null,
                    discountCode: discountCode?.code || null,
                    discountType: discountCode?.type || null,
                    discountValue: discountCode?.value || null,
                    stripePaymentIntentId: stripePaymentIntentId || null
                });

                if (xeroResponse.data.success) {
                    transactionData.xero_invoice_id = xeroResponse.data.invoice_id;
                    transactionData.xero_invoice_number = xeroResponse.data.invoice_number;
                    if (xeroResponse.data.pdf_uri) {
                        transactionData.xero_invoice_pdf_uri = xeroResponse.data.pdf_uri;
                    }
                    console.log(`[processProgramTicketPurchase] Xero invoice created: ${xeroResponse.data.invoice_number}`);
                } else {
                    console.error(`[processProgramTicketPurchase] Failed to create Xero invoice:`, xeroResponse.data);
                }
            } catch (xeroError) {
                console.error(`[processProgramTicketPurchase] Error creating Xero invoice:`, xeroError);
            }
        }

        const transaction = await base44.asServiceRole.entities.ProgramTicketTransaction.create(transactionData);

        // Update transaction reference in fully used vouchers
        for (const usage of voucherUsageDetails) {
            if (usage.fullyUsed) {
                await base44.asServiceRole.entities.Voucher.update(usage.voucherId, {
                    used_for_transaction_id: transaction.id
                });
            }
        }

        return Response.json({
            success: true,
            message: `Successfully added ${totalTicketsReceived} ${program.name} ticket${totalTicketsReceived > 1 ? 's' : ''} to ${org.name}`,
            balances: updatedProgramBalances,
            purchase_order_number: purchaseOrderNumber,
            quantity_purchased: quantity,
            total_tickets_received: totalTicketsReceived,
            free_tickets: totalTicketsReceived - quantity,
            total_cost: totalCost, // Final cost after all discounts
            discount_applied: discountAmount > 0, // Refers to appliedDiscountId discount only
            discount_amount: discountAmount, // Refers to appliedDiscountId discount amount only
            discount_code: discountCode?.code || null,
            discount_details: discountDetails, // Refers to BOGO/bulk discount details
            payment_breakdown: {
                vouchers: voucherAmountUsed,
                voucher_usage_details: voucherUsageDetails,
                training_fund: trainingFundAmount,
                account: accountAmount,
                card: cardAmount,
                payment_method: paymentMethod,
                stripe_payment_intent_id: stripePaymentIntentId
            },
            xero_invoice: transactionData.xero_invoice_number ? {
                invoice_id: transactionData.xero_invoice_id,
                invoice_number: transactionData.xero_invoice_number,
                pdf_uri: transactionData.xero_invoice_pdf_uri || null
            } : null,
            is_simulated_payment: false
        }, { status: 200 });

    } catch (error) {
        console.error('Purchase Error:', error);
        return Response.json({ 
            success: false,
            error: 'Failed to process purchase',
            message: error.message 
        }, { status: 500 });
    }
});
