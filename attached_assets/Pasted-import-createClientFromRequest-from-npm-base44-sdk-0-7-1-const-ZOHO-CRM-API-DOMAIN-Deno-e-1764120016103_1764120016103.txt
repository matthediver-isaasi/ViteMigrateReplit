import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

const ZOHO_CRM_API_DOMAIN = Deno.env.get("ZOHO_CRM_API_DOMAIN");
const ZOHO_CLIENT_ID = Deno.env.get("ZOHO_CLIENT_ID");
const ZOHO_CLIENT_SECRET = Deno.env.get("ZOHO_CLIENT_SECRET");

async function getValidAccessToken(base44) {
    const tokens = await base44.asServiceRole.entities.ZohoToken.list();
    if (tokens.length === 0) throw new Error('No tokens');
    
    const token = tokens[0];
    if (new Date(token.expires_at) > new Date()) {
        return token.access_token;
    }
    
    const accountsDomain = ZOHO_CRM_API_DOMAIN.includes('.eu') ? 'https://accounts.zoho.eu' : 'https://accounts.zoho.com';
    const refreshResponse = await fetch(`${accountsDomain}/oauth/v2/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: ZOHO_CLIENT_ID,
            client_secret: ZOHO_CLIENT_SECRET,
            refresh_token: token.refresh_token,
        }),
    });
    
    const refreshData = await refreshResponse.json();
    if (refreshData.error) throw new Error(refreshData.error);
    
    await base44.asServiceRole.entities.ZohoToken.update(token.id, {
        access_token: refreshData.access_token,
        expires_at: new Date(Date.now() + refreshData.expires_in * 1000).toISOString(),
    });
    
    return refreshData.access_token;
}

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const { email } = await req.json();
        
        if (!email) {
            return Response.json({ error: 'Email required' }, { status: 400 });
        }
        
        const accessToken = await getValidAccessToken(base44);
        
        // Get all members and find by email using JavaScript
        const allMembers = await base44.asServiceRole.entities.Member.list();
        const member = allMembers.find(m => m.email === email);
        
        if (!member) {
            return Response.json({ 
                error: 'Member not found',
                searchedEmail: email
            }, { status: 404 });
        }
        
        // Fetch fresh contact data
        const contactResponse = await fetch(
            `${ZOHO_CRM_API_DOMAIN}/crm/v3/Contacts/${member.zoho_contact_id}`,
            { headers: { 'Authorization': `Zoho-oauthtoken ${accessToken}` } }
        );
        
        if (!contactResponse.ok) {
            return Response.json({ error: 'Failed to fetch contact' }, { status: 500 });
        }
        
        const contactData = await contactResponse.json();
        const contact = contactData.data[0];
        
        // Update member last synced
        await base44.asServiceRole.entities.Member.update(member.id, {
            last_synced: new Date().toISOString()
        });
        
        let trainingFundBalance = 0;
        let purchaseOrderEnabled = false;
        
        if (member.organization_id && contact.Account_Name?.id) {
            const accountResponse = await fetch(
                `${ZOHO_CRM_API_DOMAIN}/crm/v3/Accounts/${contact.Account_Name.id}`,
                { headers: { 'Authorization': `Zoho-oauthtoken ${accessToken}` } }
            );
            
            if (accountResponse.ok) {
                const accountData = await accountResponse.json();
                const account = accountData.data[0];
                
                trainingFundBalance = account.Training_fund_balance || 0;
                purchaseOrderEnabled = account.Purchase_Order_Enabled || false;
                
                const allOrgs = await base44.asServiceRole.entities.Organization.list();
                const org = allOrgs.find(o => o.zoho_account_id === contact.Account_Name.id);
                
                if (org) {
                    await base44.asServiceRole.entities.Organization.update(org.id, {
                        training_fund_balance: trainingFundBalance,
                        purchase_order_enabled: purchaseOrderEnabled,
                        last_synced: new Date().toISOString()
                    });
                }
            }
        }
        
        return Response.json({
            success: true,
            training_fund_balance: trainingFundBalance,
            purchase_order_enabled: purchaseOrderEnabled
        });
        
    } catch (error) {
        console.error('Refresh error:', error);
        return Response.json({ error: error.message }, { status: 500 });
    }
});