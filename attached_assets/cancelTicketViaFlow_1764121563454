import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        
        const { orderId, cancelReason = "Cancelled by member via iConnect", memberId } = await req.json();
        
        if (!orderId) {
            return Response.json({ 
                success: false,
                error: 'Missing required parameter: orderId' 
            }, { status: 400 });
        }

        if (!memberId) {
            return Response.json({ 
                success: false,
                error: 'Missing required parameter: memberId' 
            }, { status: 400 });
        }

        console.log('Cancelling order:', orderId, 'for member:', memberId);

        // STEP 1: Find the booking and verify authorization
        const allBookings = await base44.asServiceRole.entities.Booking.list();
        const booking = allBookings.find(b => b.backstage_order_id === orderId);
        
        if (!booking) {
            return Response.json({ 
                success: false,
                error: 'Booking not found with this order ID' 
            }, { status: 404 });
        }

        // Authorization check: Verify the requesting member owns this booking
        if (booking.member_id !== memberId) {
            console.error('Authorization failed: Member', memberId, 'attempted to cancel booking belonging to', booking.member_id);
            return Response.json({ 
                success: false,
                error: 'Unauthorized: You can only cancel your own bookings' 
            }, { status: 403 });
        }

        // Check if already cancelled
        if (booking.status === 'cancelled') {
            return Response.json({ 
                success: true,
                message: 'Ticket already cancelled'
            });
        }

        // Get the event to find the program tag
        const allEvents = await base44.asServiceRole.entities.Event.list();
        const event = allEvents.find(e => e.id === booking.event_id);
        
        if (!event || !event.program_tag) {
            console.warn('Event not found or missing program tag, proceeding with cancellation anyway');
        }

        // Get the member to find organization
        const allMembers = await base44.asServiceRole.entities.Member.list();
        const member = allMembers.find(m => m.id === booking.member_id);
        
        let organizationId = null;
        if (member && member.organization_id) {
            organizationId = member.organization_id;
        }

        // STEP 2: Return the program ticket to the organization's balance
        if (organizationId && event && event.program_tag) {
            const allOrgs = await base44.asServiceRole.entities.Organization.list();
            let org = allOrgs.find(o => o.id === organizationId);
            
            if (!org) {
                org = allOrgs.find(o => o.zoho_account_id === organizationId);
            }
            
            if (org) {
                const currentBalances = org.program_ticket_balances || {};
                const currentBalance = currentBalances[event.program_tag] || 0;
                const newBalance = currentBalance + 1; // Return 1 ticket
                
                const updatedBalances = {
                    ...currentBalances,
                    [event.program_tag]: newBalance
                };
                
                await base44.asServiceRole.entities.Organization.update(org.id, {
                    program_ticket_balances: updatedBalances,
                    last_synced: new Date().toISOString()
                });
                
                console.log(`Returned 1 ticket to ${event.program_tag}. New balance: ${newBalance}`);
                
                // STEP 3: Create a refund transaction record
                await base44.asServiceRole.entities.ProgramTicketTransaction.create({
                    organization_id: org.id,
                    program_name: event.program_tag,
                    transaction_type: 'refund',
                    quantity: 1,
                    booking_reference: booking.booking_reference || orderId,
                    event_name: event.title || 'Unknown Event',
                    member_email: member?.email || booking.attendee_email || 'unknown',
                    notes: `Ticket refunded due to cancellation: ${cancelReason}`
                });
                
                console.log('Created refund transaction record');
            }
        }

        // STEP 4: Update booking status to cancelled in our database
        await base44.asServiceRole.entities.Booking.update(booking.id, {
            status: 'cancelled'
        });
        console.log('Updated booking status to cancelled in database');

        // STEP 5: Call Zoho Flow webhook to cancel in Backstage
        const response = await fetch(
            'https://flow.zoho.eu/20108063378/flow/webhook/incoming?zapikey=1001.ee25c218c557d7dddb0eed4f3e0e981a.70bb4e51162d59156ab4899ad8bcc38c&isdebug=false',
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    order_id: orderId,
                    cancel_reason: cancelReason
                })
            }
        );

        if (response.ok) {
            console.log('Zoho Flow webhook called successfully');
            return Response.json({ 
                success: true,
                message: 'Ticket cancelled successfully' 
            });
        } else {
            const errorText = await response.text();
            console.error('Zoho Flow webhook error:', errorText);
            
            // Even if Flow webhook fails, we've already marked it as cancelled locally
            // and returned the ticket to the balance
            return Response.json({ 
                success: true,
                message: 'Ticket marked as cancelled. Backstage sync may take a moment.',
                warning: 'Backstage API call failed but local status updated'
            });
        }

    } catch (error) {
        console.error('Cancellation error:', error);
        return Response.json({ 
            success: false,
            error: error.message 
        }, { status: 500 });
    }
});