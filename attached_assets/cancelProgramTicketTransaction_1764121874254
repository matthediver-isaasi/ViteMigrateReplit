import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        
        const { transactionId, quantityToCancel, adminEmail } = await req.json();
        
        console.log('[cancelProgramTicketTransaction] ========================================');
        console.log('[cancelProgramTicketTransaction] Cancellation request received');
        console.log('[cancelProgramTicketTransaction] Transaction ID:', transactionId);
        console.log('[cancelProgramTicketTransaction] Quantity to Cancel:', quantityToCancel);
        console.log('[cancelProgramTicketTransaction] Admin Email:', adminEmail);
        
        // Validate inputs
        if (!transactionId || !quantityToCancel || !adminEmail) {
            return Response.json({
                success: false,
                error: 'Missing required parameters',
                required: ['transactionId', 'quantityToCancel', 'adminEmail']
            }, { status: 400 });
        }

        if (quantityToCancel <= 0) {
            return Response.json({
                success: false,
                error: 'Quantity to cancel must be greater than 0'
            }, { status: 400 });
        }

        // Verify admin privileges
        const allMembers = await base44.asServiceRole.entities.Member.list();
        const adminMember = allMembers.find(m => m.email === adminEmail);
        
        if (!adminMember || !adminMember.role_id) {
            return Response.json({
                success: false,
                error: 'Admin user not found or has no role assigned'
            }, { status: 403 });
        }

        const allRoles = await base44.asServiceRole.entities.Role.list();
        const adminRole = allRoles.find(r => r.id === adminMember.role_id);
        
        if (!adminRole || !adminRole.is_admin) {
            return Response.json({
                success: false,
                error: 'User does not have administrator privileges'
            }, { status: 403 });
        }

        console.log('[cancelProgramTicketTransaction] Admin authorization verified');

        // Fetch the original transaction
        const allTransactions = await base44.asServiceRole.entities.ProgramTicketTransaction.list();
        const transaction = allTransactions.find(t => t.id === transactionId);

        if (!transaction) {
            return Response.json({
                success: false,
                error: 'Transaction not found'
            }, { status: 404 });
        }

        console.log('[cancelProgramTicketTransaction] Transaction found:', {
            type: transaction.transaction_type,
            program: transaction.program_name,
            original_quantity: transaction.original_quantity || transaction.quantity,
            cancelled_quantity: transaction.cancelled_quantity || 0,
            status: transaction.status
        });

        // Validate transaction type
        if (transaction.transaction_type !== 'purchase') {
            return Response.json({
                success: false,
                error: 'Only purchase transactions can be cancelled',
                transaction_type: transaction.transaction_type
            }, { status: 400 });
        }

        // Validate transaction status
        if (transaction.status === 'cancelled') {
            return Response.json({
                success: false,
                error: 'This transaction has already been fully cancelled'
            }, { status: 400 });
        }

        // Calculate available quantity to cancel
        const originalQuantity = transaction.original_quantity || transaction.quantity;
        const alreadyCancelled = transaction.cancelled_quantity || 0;
        const availableToCancelFromThisPurchase = originalQuantity - alreadyCancelled;

        console.log('[cancelProgramTicketTransaction] Cancellation capacity:', {
            originalQuantity,
            alreadyCancelled,
            availableToCancelFromThisPurchase,
            requestedToCancel: quantityToCancel
        });

        if (quantityToCancel > availableToCancelFromThisPurchase) {
            return Response.json({
                success: false,
                error: `Cannot cancel ${quantityToCancel} tickets. Only ${availableToCancelFromThisPurchase} ticket(s) available to cancel from this purchase.`,
                available_to_cancel: availableToCancelFromThisPurchase
            }, { status: 400 });
        }

        // Fetch the organization
        const allOrganizations = await base44.asServiceRole.entities.Organization.list();
        const organization = allOrganizations.find(o => o.id === transaction.organization_id);

        if (!organization) {
            return Response.json({
                success: false,
                error: 'Organization not found'
            }, { status: 404 });
        }

        // CRITICAL RULE: Check if tickets have been allocated (used)
        const currentOrgBalance = (organization.program_ticket_balances || {})[transaction.program_name] || 0;

        console.log('[cancelProgramTicketTransaction] Allocation check:', {
            currentOrgBalance,
            quantityToCancel,
            canCancel: currentOrgBalance >= quantityToCancel
        });

        if (currentOrgBalance < quantityToCancel) {
            return Response.json({
                success: false,
                error: `Cannot cancel ${quantityToCancel} ticket(s). Only ${currentOrgBalance} unallocated ticket(s) remain in the organization's balance. The remaining ${quantityToCancel - currentOrgBalance} ticket(s) have been allocated/used and cannot be cancelled through this system.`,
                current_balance: currentOrgBalance,
                requested_to_cancel: quantityToCancel,
                unallocated_tickets: currentOrgBalance
            }, { status: 400 });
        }

        // All validations passed - proceed with cancellation
        console.log('[cancelProgramTicketTransaction] ✓ All validations passed. Proceeding with cancellation...');

        // Update the original transaction record
        const newCancelledQuantity = alreadyCancelled + quantityToCancel;
        const isFullyCancelled = newCancelledQuantity >= originalQuantity;

        const transactionUpdates = {
            cancelled_quantity: newCancelledQuantity,
            status: isFullyCancelled ? 'cancelled' : 'active',
            cancelled_by_member_email: adminEmail,
            cancelled_at: new Date().toISOString()
        };

        // If this is the first cancellation, also set original_quantity
        if (!transaction.original_quantity) {
            transactionUpdates.original_quantity = transaction.quantity;
        }

        await base44.asServiceRole.entities.ProgramTicketTransaction.update(transactionId, transactionUpdates);
        console.log('[cancelProgramTicketTransaction] ✓ Transaction record updated');

        // Update organization's balance
        const updatedProgramBalances = {
            ...organization.program_ticket_balances,
            [transaction.program_name]: currentOrgBalance - quantityToCancel
        };

        await base44.asServiceRole.entities.Organization.update(organization.id, {
            program_ticket_balances: updatedProgramBalances,
            last_synced: new Date().toISOString()
        });
        console.log('[cancelProgramTicketTransaction] ✓ Organization balance updated');

        // Create audit trail transaction
        await base44.asServiceRole.entities.ProgramTicketTransaction.create({
            organization_id: transaction.organization_id,
            program_name: transaction.program_name,
            transaction_type: 'cancellation_void',
            quantity: quantityToCancel,
            member_email: adminEmail,
            original_transaction_id: transactionId,
            notes: `Admin cancellation: ${quantityToCancel} ticket(s) voided from purchase transaction. Original PO: ${transaction.purchase_order_number || 'N/A'}. Reason: Administrative correction.`
        });
        console.log('[cancelProgramTicketTransaction] ✓ Audit trail created');

        console.log('[cancelProgramTicketTransaction] ========================================');
        console.log('[cancelProgramTicketTransaction] CANCELLATION SUCCESSFUL');
        console.log('[cancelProgramTicketTransaction] ========================================');

        return Response.json({
            success: true,
            message: `Successfully cancelled ${quantityToCancel} ticket(s)`,
            transaction_id: transactionId,
            quantity_cancelled: quantityToCancel,
            total_cancelled_from_transaction: newCancelledQuantity,
            transaction_status: isFullyCancelled ? 'fully_cancelled' : 'partially_cancelled',
            remaining_in_transaction: originalQuantity - newCancelledQuantity,
            new_organization_balance: updatedProgramBalances[transaction.program_name]
        });

    } catch (error) {
        console.error('[cancelProgramTicketTransaction] Fatal error:', error);
        return Response.json({
            success: false,
            error: 'Failed to cancel transaction',
            details: error.message
        }, { status: 500 });
    }
});