
import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

const ZOHO_CLIENT_ID = Deno.env.get("ZOHO_CLIENT_ID");
const ZOHO_CLIENT_SECRET = Deno.env.get("ZOHO_CLIENT_SECRET");
const ZOHO_CRM_API_DOMAIN = Deno.env.get("ZOHO_CRM_API_DOMAIN");

function getAccountsDomain(apiDomain) {
    if (apiDomain.includes('.zohoapis.eu')) {
        return 'https://accounts.zoho.eu';
    } else if (apiDomain.includes('.zohoapis.com.au')) {
        return 'https://accounts.zoho.com.au';
    } else {
        return 'https://accounts.zoho.com';
    }
}

async function getValidAccessToken(base44) {
    const tokens = await base44.asServiceRole.entities.ZohoToken.list();
    if (tokens.length === 0) {
        throw new Error('No Zoho tokens found');
    }
    
    const token = tokens[0];
    if (new Date(token.expires_at) > new Date()) {
        return token.access_token;
    }
    
    const accountsDomain = getAccountsDomain(ZOHO_CRM_API_DOMAIN || 'https://www.zohoapis.com');
    const refreshResponse = await fetch(`${accountsDomain}/oauth/v2/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: ZOHO_CLIENT_ID || '',
            client_secret: ZOHO_CLIENT_SECRET || '',
            refresh_token: token.refresh_token,
        }),
    });
    
    const refreshData = await refreshResponse.json();
    if (refreshData.error) {
        throw new Error(`Failed to refresh Zoho token: ${refreshData.error_description || refreshData.error}`);
    }
    
    await base44.asServiceRole.entities.ZohoToken.update(token.id, {
        access_token: refreshData.access_token,
        expires_at: new Date(Date.now() + refreshData.expires_in * 1000).toISOString(),
    });
    
    return refreshData.access_token;
}

function generateBookingReference() {
    return 'BK-' + Date.now() + '-' + Math.random().toString(36).substring(2, 8).toUpperCase();
}

async function checkExistingBackstageRegistrations(accessToken, backstageEventId, attendeeEmails) {
    const portalId = "20108049755";
    const baseUrl = "https://www.zohoapis.eu/backstage/v3";
    
    console.log(`[checkExistingBackstageRegistrations] Checking ${attendeeEmails.length} emails for event ${backstageEventId}`);
    
    try {
        // Fetch all orders for this event
        const ordersUrl = `${baseUrl}/portals/${portalId}/events/${backstageEventId}/orders`;
        const ordersResponse = await fetch(ordersUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Zoho-oauthtoken ${accessToken}`
            }
        });

        if (!ordersResponse.ok) {
            console.error('[checkExistingBackstageRegistrations] Failed to fetch orders:', ordersResponse.status);
            return { hasDuplicates: false, duplicateEmails: [] };
        }

        const ordersData = await ordersResponse.json();
        const orders = ordersData.orders || [];
        
        console.log(`[checkExistingBackstageRegistrations] Found ${orders.length} existing orders`);

        // Collect all registered emails from ACTIVE tickets only
        const registeredEmails = new Set();
        
        for (const order of orders) {
            const tickets = order.tickets || [];
            
            if (Array.isArray(tickets)) {
                for (const ticket of tickets) {
                    const ticketStatus = ticket.status_string || '';
                    
                    // Skip cancelled or refunded tickets
                    if (ticketStatus === 'cancelled' || ticketStatus === 'refunded') {
                        console.log(`[checkExistingBackstageRegistrations] Skipping ${ticketStatus} ticket ${ticket.id} for email: ${ticket.contact?.email}`);
                        continue;
                    }
                    
                    // Only add emails from ACTIVE tickets
                    if (ticket.contact?.email) {
                        registeredEmails.add(ticket.contact.email.toLowerCase());
                        console.log(`[checkExistingBackstageRegistrations] Found active ticket email: ${ticket.contact.email} (ticket status: ${ticketStatus})`);
                    }
                }
            }
        }

        console.log(`[checkExistingBackstageRegistrations] Found ${registeredEmails.size} unique registered emails (active tickets only)`);
        console.log(`[checkExistingBackstageRegistrations] Registered emails:`, Array.from(registeredEmails));

        // Check for duplicates
        const duplicateEmails = [];
        for (const email of attendeeEmails) {
            if (registeredEmails.has(email.toLowerCase())) {
                duplicateEmails.push(email);
            }
        }

        if (duplicateEmails.length > 0) {
            console.log(`[checkExistingBackstageRegistrations] Duplicate emails found:`, duplicateEmails);
            return { hasDuplicates: true, duplicateEmails };
        }

        console.log('[checkExistingBackstageRegistrations] No duplicates found');
        return { hasDuplicates: false, duplicateEmails: [] };

    } catch (error) {
        console.error('[checkExistingBackstageRegistrations] Error checking registrations:', error);
        return { hasDuplicates: false, duplicateEmails: [] };
    }
}

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const { 
            eventId, 
            memberEmail, 
            attendees, 
            registrationMode,
            numberOfLinks = 0,
            ticketsRequired,
            programTag
        } = await req.json();
        
        if (!eventId || !memberEmail) {
            return Response.json({ 
                success: false,
                error: 'Missing required parameters: eventId and memberEmail' 
            }, { status: 400 });
        }

        if (registrationMode === 'colleagues' && (!attendees || attendees.length === 0)) {
            return Response.json({ 
                success: false,
                error: 'No attendees provided for colleagues registration' 
            }, { status: 400 });
        }

        if (registrationMode === 'links' && numberOfLinks < 1) {
            return Response.json({ 
                success: false,
                error: 'Number of links must be at least 1' 
            }, { status: 400 });
        }

        if (registrationMode === 'self' && (!attendees || attendees.length === 0)) {
            return Response.json({ 
                success: false,
                error: 'No attendee information provided for self registration' 
            }, { status: 400 });
        }

        // Get member details
        const allMembers = await base44.asServiceRole.entities.Member.list();
        const member = allMembers.find((m) => m.email === memberEmail);

        if (!member) {
            return Response.json({ 
                success: false,
                error: 'Member not found' 
            }, { status: 404 });
        }

        // Get event details
        const allEvents = await base44.asServiceRole.entities.Event.list();
        const event = allEvents.find((e) => e.id === eventId);

        if (!event) {
            return Response.json({ 
                success: false,
                error: 'Event not found' 
            }, { status: 404 });
        }

        // Check if event requires program tickets
        if (!programTag || !event.program_tag) {
            return Response.json({
                success: false,
                error: 'This event does not have a program association and cannot be booked'
            }, { status: 400 });
        }

        // Get organization and verify program ticket balance
        if (!member.organization_id) {
            return Response.json({
                success: false,
                error: 'Member does not have an associated organization'
            }, { status: 400 });
        }

        const allOrgs = await base44.asServiceRole.entities.Organization.list();
        let org = allOrgs.find((o) => o.id === member.organization_id);
        
        if (!org) {
            org = allOrgs.find((o) => o.zoho_account_id === member.organization_id);
        }

        if (!org) {
            return Response.json({
                success: false,
                error: 'Organization not found'
            }, { status: 404 });
        }

        // Check program ticket balance
        const currentBalances = org.program_ticket_balances || {};
        const currentBalance = currentBalances[programTag] || 0;
        
        if (currentBalance < ticketsRequired) {
            return Response.json({
                success: false,
                error: `Insufficient program tickets. Required: ${ticketsRequired}, Available: ${currentBalance}`
            }, { status: 400 });
        }

        // NEW: Check for duplicate registrations in Backstage before proceeding
        if ((registrationMode === 'self' || registrationMode === 'colleagues') && event.backstage_event_id && attendees) {
            console.log('[createBooking] Checking for duplicate registrations in Backstage...');
            
            const accessToken = await getValidAccessToken(base44);
            const attendeeEmails = attendees.map(a => a.email).filter(Boolean);
            
            const duplicateCheck = await checkExistingBackstageRegistrations(
                accessToken,
                event.backstage_event_id,
                attendeeEmails
            );

            if (duplicateCheck.hasDuplicates) {
                const emailList = duplicateCheck.duplicateEmails.join(', ');
                return Response.json({
                    success: false,
                    error: `The following email address(es) are already registered for this event: ${emailList}. Please remove them and try again.`,
                    duplicateEmails: duplicateCheck.duplicateEmails
                }, { status: 409 }); // 409 Conflict status code
            }
        }

        // Create bookings
        const bookingReference = generateBookingReference();
        const createdBookings = [];
        let anyBackstageSyncFailed = false;
        const backstageSyncErrors = [];
        const individualBackstageOrderDetails = []; // To store Backstage order ID for each attendee

        // For self/colleagues mode, provision a separate ticket (order) in Backstage for EACH attendee
        if ((registrationMode === 'self' || registrationMode === 'colleagues') && event.backstage_event_id) {
            try {
                console.log('[createBooking] Attempting to provision tickets as individual orders in Backstage...');
                const accessToken = await getValidAccessToken(base44);
                
                const portalId = "20108049755";
                const baseUrl = "https://www.zohoapis.eu/backstage/v3";
                
                // Step 1: Dynamically fetch ticket classes for this event
                const ticketClassesUrl = `${baseUrl}/portals/${portalId}/events/${event.backstage_event_id}/ticket_classes`;
                console.log('[createBooking] Fetching ticket classes from:', ticketClassesUrl);
                
                const ticketClassesResponse = await fetch(ticketClassesUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Zoho-oauthtoken ${accessToken}`
                    }
                });

                if (!ticketClassesResponse.ok) {
                    const errorText = await ticketClassesResponse.text();
                    console.error('[createBooking] Failed to fetch ticket classes:', errorText);
                    anyBackstageSyncFailed = true;
                    backstageSyncErrors.push(`Failed to fetch ticket classes: ${errorText}`);
                    throw new Error(`Failed to fetch ticket classes: ${errorText}`); // Propagate error early
                }

                const ticketClassesData = await ticketClassesResponse.json();
                const ticketClasses = ticketClassesData.ticket_classes || [];
                
                console.log('[createBooking] Found ticket classes:', ticketClasses.length);
                
                // Step 2: Find the free "Member" ticket class
                let memberTicket = ticketClasses.find(tc => 
                    tc.ticket_class_type_string === 'free' && 
                    tc.translation?.name?.toLowerCase() === 'member'
                );
                
                // Fallback: if no "Member" ticket found, use the first free ticket
                if (!memberTicket) {
                    memberTicket = ticketClasses.find(tc => tc.ticket_class_type_string === 'free');
                }
                
                // Final fallback: use the first ticket class (matching Deluge's classList.get(0))
                if (!memberTicket && ticketClasses.length > 0) {
                    memberTicket = ticketClasses[0];
                    console.log('[createBooking] Warning: No free ticket found, using first ticket class');
                }
                
                if (!memberTicket) {
                    console.error('[createBooking] No ticket classes available for this event');
                    anyBackstageSyncFailed = true;
                    backstageSyncErrors.push('No ticket classes available for this event');
                    throw new Error('No ticket classes available for this event'); // Propagate error early
                }
                
                const ticketClassId = memberTicket.id.toString();
                console.log('[createBooking] Using ticket class:', {
                    id: ticketClassId,
                    name: memberTicket.translation?.name,
                    type: memberTicket.ticket_class_type_string,
                    price: memberTicket.amount
                });
                
                // Step 3 & 4: Create a separate order for each attendee
                const backstageApiUrl = `${baseUrl}/portals/${portalId}/events/${event.backstage_event_id}/orders`;
                
                for (const attendee of attendees) {
                    const buyerDetails = {};
                    if (member.first_name) buyerDetails.purchaser_first_name = member.first_name;
                    if (member.last_name) buyerDetails.purchaser_last_name = member.last_name;
                    if (member.email) buyerDetails.purchaser_email = member.email;
                    if (org.name) buyerDetails.purchaser_company = org.name;
                    
                    const singleTicket = [{
                        ticketclass_id: ticketClassId,
                        data: {
                            first_name: attendee.first_name,
                            last_name: attendee.last_name,
                            email: attendee.email
                        }
                    }];
                    
                    const singleOrderPayload = {
                        buyer_details: buyerDetails,
                        tickets: singleTicket
                    };

                    console.log(`[createBooking] Backstage order payload for ${attendee.email}:`, JSON.stringify(singleOrderPayload, null, 2));

                    try {
                        const individualBackstageResponse = await fetch(backstageApiUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Zoho-oauthtoken ${accessToken}`
                            },
                            body: JSON.stringify(singleOrderPayload)
                        });

                        if (individualBackstageResponse.ok) {
                            const backstageData = await individualBackstageResponse.json();
                            const individualBackstageOrderId = backstageData.order?.id || backstageData.id;
                            individualBackstageOrderDetails.push({
                                attendeeEmail: attendee.email,
                                backstageOrderId: individualBackstageOrderId,
                                success: true
                            });
                            console.log(`[createBooking] ✓ Backstage individual order created for ${attendee.email}: ${individualBackstageOrderId}`);
                        } else {
                            const errorText = await individualBackstageResponse.text();
                            console.error(`[createBooking] ✗ Backstage API error response for ${attendee.email}: ${individualBackstageResponse.status} ${errorText}`);
                            anyBackstageSyncFailed = true;
                            backstageSyncErrors.push(`Backstage API Error (${individualBackstageResponse.status}) for ${attendee.email}: ${errorText}`);
                            individualBackstageOrderDetails.push({
                                attendeeEmail: attendee.email,
                                success: false,
                                error: `API Error: ${errorText}`
                            });
                        }
                    } catch (individualBackstageError) {
                        console.error(`[createBooking] ✗ Backstage provisioning failed for ${attendee.email}:`, individualBackstageError);
                        anyBackstageSyncFailed = true;
                        backstageSyncErrors.push(`Backstage Provisioning Failed for ${attendee.email}: ${individualBackstageError.message}`);
                        individualBackstageOrderDetails.push({
                            attendeeEmail: attendee.email,
                            success: false,
                            error: `Provisioning Error: ${individualBackstageError.message}`
                        });
                    }
                }

            } catch (backstageError) {
                console.error('[createBooking] ✗ Backstage provisioning process failed:', backstageError);
                anyBackstageSyncFailed = true;
                backstageSyncErrors.push(`Backstage Provisioning Process Error: ${backstageError.message}`);
            }
        } else if ((registrationMode === 'self' || registrationMode === 'colleagues') && !event.backstage_event_id) {
            console.warn('[createBooking] Backstage provisioning skipped: Missing event backstage_event_id.');
            anyBackstageSyncFailed = true; // Mark as failed because Backstage sync was expected but couldn't happen
            backstageSyncErrors.push('Backstage provisioning skipped due to missing event configuration.');
        }

        if (registrationMode === 'self' || registrationMode === 'colleagues') {
            // Create booking for each attendee (including self-registration)
            for (const attendee of attendees) {
                const correspondingBackstageOrder = individualBackstageOrderDetails.find(d => d.attendeeEmail === attendee.email);
                
                const booking = await base44.asServiceRole.entities.Booking.create({
                    event_id: eventId,
                    member_id: member.id,
                    attendee_email: attendee.email,
                    attendee_first_name: attendee.first_name,
                    attendee_last_name: attendee.last_name,
                    ticket_price: event.ticket_price || 0,
                    booking_reference: bookingReference,
                    status: correspondingBackstageOrder?.success ? 'confirmed' : 'pending_backstage_sync', // Mark as pending if Backstage creation failed for this specific attendee
                    payment_method: 'program_ticket',
                    backstage_order_id: correspondingBackstageOrder?.backstageOrderId || null // Store the individual order ID
                });
                createdBookings.push(booking);
            }
        } else if (registrationMode === 'links') {
            // Create placeholder bookings for links (to be claimed later)
            for (let i = 0; i < numberOfLinks; i++) {
                const confirmationToken = crypto.randomUUID();
                const booking = await base44.asServiceRole.entities.Booking.create({
                    event_id: eventId,
                    member_id: member.id,
                    attendee_email: '',
                    attendee_first_name: '',
                    attendee_last_name: '',
                    ticket_price: event.ticket_price || 0,
                    booking_reference: bookingReference,
                    status: 'pending',
                    payment_method: 'program_ticket',
                    confirmation_token: confirmationToken
                });
                createdBookings.push(booking);
            }
        }

        // Deduct program tickets from organization balance
        const newBalance = currentBalance - ticketsRequired;
        const updatedBalances = {
            ...currentBalances,
            [programTag]: newBalance
        };
        
        await base44.asServiceRole.entities.Organization.update(org.id, {
            program_ticket_balances: updatedBalances,
            last_synced: new Date().toISOString()
        });

        // Create program ticket transaction record
        await base44.asServiceRole.entities.ProgramTicketTransaction.create({
            organization_id: org.id,
            program_name: programTag,
            transaction_type: 'usage',
            quantity: ticketsRequired,
            booking_reference: bookingReference,
            event_name: event.title || 'Unknown Event',
            member_email: memberEmail,
            notes: `Used ${ticketsRequired} ${programTag} ticket${ticketsRequired > 1 ? 's' : ''} for ${event.title || 'event'}${registrationMode === 'links' ? ' (link generation)' : registrationMode === 'self' ? ' (self registration)' : ''}${anyBackstageSyncFailed ? ' - Backstage sync failed for some tickets' : ''}`
        });

        const response = {
            success: true,
            booking_reference: bookingReference,
            bookings: createdBookings,
            tickets_used: ticketsRequired,
            remaining_balance: newBalance
        };

        // Add warning if any Backstage sync failed
        if (anyBackstageSyncFailed) {
            response.warning = 'Some bookings created successfully, but Backstage provisioning failed for one or more tickets. An admin may need to manually sync these.';
            response.backstage_sync_errors = backstageSyncErrors;
        }

        return Response.json(response);

    } catch (error) {
        console.error('Booking error:', error);
        return Response.json({ 
            success: false,
            error: error.message 
        }, { status: 500 });
    }
});
