import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

const ZOHO_BACKSTAGE_PORTAL_NAME = Deno.env.get("ZOHO_BACKSTAGE_PORTAL_NAME");

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const { accessToken } = await req.json();
        
        if (!accessToken) {
            return Response.json({ 
                error: 'Missing access token' 
            }, { status: 400 });
        }

        // Fetch events from Zoho Backstage V3 API
        const eventsResponse = await fetch(
            `https://backstage.zoho.com/api/v3/${ZOHO_BACKSTAGE_PORTAL_NAME}/events`,
            {
                headers: {
                    'Authorization': `Zoho-oauthtoken ${accessToken}`,
                    'Content-Type': 'application/json',
                },
            }
        );

        if (!eventsResponse.ok) {
            const errorData = await eventsResponse.text();
            return Response.json({ 
                error: 'Failed to fetch events from Backstage',
                details: errorData 
            }, { status: eventsResponse.status });
        }

        const eventsData = await eventsResponse.json();
        const events = eventsData.data || [];

        let syncedCount = 0;
        let errorCount = 0;

        // Get all existing events once
        const allExistingEvents = await base44.asServiceRole.entities.Event.list();

        // Sync each event to base44 using service role
        for (const event of events) {
            try {
                // Extract program tag (first tag in the list)
                const programTag = event.tags && event.tags.length > 0 ? event.tags[0] : null;

                const eventData = {
                    title: event.name,
                    description: event.description || '',
                    program_tag: programTag,
                    start_date: event.start_time,
                    end_date: event.end_time,
                    location: event.venue?.name || 'Online',
                    ticket_price: event.tickets?.[0]?.price || 0,
                    available_seats: event.tickets?.[0]?.quantity_available || 0,
                    backstage_event_id: event.id,
                    image_url: event.banner_url || null,
                    last_synced: new Date().toISOString()
                };

                // Check if event already exists using JavaScript find
                const existingEvent = allExistingEvents.find(e => e.backstage_event_id === event.id);

                if (existingEvent) {
                    await base44.asServiceRole.entities.Event.update(existingEvent.id, eventData);
                } else {
                    await base44.asServiceRole.entities.Event.create(eventData);
                }

                syncedCount++;
            } catch (error) {
                console.error(`Error syncing event ${event.id}:`, error);
                errorCount++;
            }
        }

        return Response.json({
            success: true,
            synced: syncedCount,
            errors: errorCount,
            total: events.length
        });

    } catch (error) {
        return Response.json({ 
            error: 'Failed to sync events',
            message: error.message 
        }, { status: 500 });
    }
});