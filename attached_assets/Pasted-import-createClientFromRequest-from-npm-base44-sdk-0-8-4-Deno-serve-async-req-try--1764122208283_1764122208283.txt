import { createClientFromRequest } from 'npm:@base44/sdk@0.8.4';

Deno.serve(async (req) => {
  try {
    const base44 = createClientFromRequest(req);
    
    // Authenticate user
    const user = await base44.auth.me();
    if (!user) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { categoryId, oldSubcategoryName, newSubcategoryName } = await req.json();

    // Validate input
    if (!categoryId || !oldSubcategoryName || !newSubcategoryName) {
      return Response.json({ 
        success: false, 
        error: 'Missing required parameters: categoryId, oldSubcategoryName, newSubcategoryName' 
      }, { status: 400 });
    }

    if (oldSubcategoryName === newSubcategoryName) {
      return Response.json({ 
        success: false, 
        error: 'New subcategory name must be different from the old name' 
      }, { status: 400 });
    }

    // Trim the names
    const oldName = oldSubcategoryName.trim();
    const newName = newSubcategoryName.trim();

    if (!newName) {
      return Response.json({ 
        success: false, 
        error: 'New subcategory name cannot be empty' 
      }, { status: 400 });
    }

    // Use service role for all operations
    const serviceBase44 = base44.asServiceRole;

    // 1. Get the category
    const categories = await serviceBase44.entities.ResourceCategory.list();
    const category = categories.find(c => c.id === categoryId);

    if (!category) {
      return Response.json({ 
        success: false, 
        error: 'Category not found' 
      }, { status: 404 });
    }

    // 2. Check if old subcategory exists in the category
    if (!category.subcategories || !category.subcategories.includes(oldName)) {
      return Response.json({ 
        success: false, 
        error: 'Old subcategory name not found in category' 
      }, { status: 404 });
    }

    // 3. Check if new subcategory name already exists (case-insensitive)
    const subcategoriesLowerCase = category.subcategories.map(s => s.toLowerCase());
    if (subcategoriesLowerCase.includes(newName.toLowerCase()) && oldName.toLowerCase() !== newName.toLowerCase()) {
      return Response.json({ 
        success: false, 
        error: 'A subcategory with this name already exists in the category' 
      }, { status: 400 });
    }

    // 4. Update the ResourceCategory entity
    const updatedSubcategories = category.subcategories.map(sub => 
      sub === oldName ? newName : sub
    );

    // Sort alphabetically
    updatedSubcategories.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

    await serviceBase44.entities.ResourceCategory.update(categoryId, {
      subcategories: updatedSubcategories
    });

    // 5. Find and update all Resource entities with the old subcategory name
    const allResources = await serviceBase44.entities.Resource.list();
    const resourcesToUpdate = allResources.filter(resource => 
      resource.subcategories && resource.subcategories.includes(oldName)
    );

    console.log(`Found ${resourcesToUpdate.length} resources to update`);

    // Update each resource
    const updatePromises = resourcesToUpdate.map(resource => {
      const updatedResourceSubcategories = resource.subcategories.map(sub =>
        sub === oldName ? newName : sub
      );

      return serviceBase44.entities.Resource.update(resource.id, {
        subcategories: updatedResourceSubcategories
      });
    });

    await Promise.all(updatePromises);

    console.log(`Successfully renamed subcategory from "${oldName}" to "${newName}" in category "${category.name}"`);
    console.log(`Updated ${resourcesToUpdate.length} resource(s)`);

    return Response.json({
      success: true,
      message: `Successfully renamed subcategory and updated ${resourcesToUpdate.length} resource(s)`,
      resourcesUpdated: resourcesToUpdate.length
    });

  } catch (error) {
    console.error('Error renaming subcategory:', error);
    return Response.json({ 
      success: false, 
      error: error.message 
    }, { status: 500 });
  }
});